/// CustomSubs - Privacy-First Subscription Tracker
///
/// A Flutter application for tracking subscriptions with complete privacy.
/// All data stays on-device with no cloud sync or network calls.
///
/// Key features:
/// - Offline-only operation
/// - Local Hive database
/// - Smart notifications with timezone support
/// - Multi-currency support with bundled exchange rates
/// - 40+ pre-populated subscription templates
library;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:timezone/data/latest_all.dart' as tz;
import 'package:timezone/timezone.dart' as tz;
import 'package:flutter_timezone/flutter_timezone.dart';
import 'package:custom_subs/app/app.dart';
import 'package:custom_subs/data/models/subscription.dart';
import 'package:custom_subs/data/models/subscription_cycle.dart';
import 'package:custom_subs/data/models/subscription_category.dart';
import 'package:custom_subs/data/models/reminder_config.dart';
import 'package:custom_subs/data/models/monthly_snapshot.dart';
import 'package:custom_subs/data/repositories/subscription_repository.dart';
import 'package:custom_subs/data/services/notification_service.dart';
import 'package:custom_subs/data/services/entitlement_service.dart';
import 'package:custom_subs/core/utils/currency_utils.dart';

/// Application entry point.
///
/// Performs critical initialization before starting the app:
/// 1. Initializes Hive database and registers type adapters
/// 2. Loads timezone data for notification scheduling
/// 3. Loads bundled currency exchange rates
/// 4. Initializes repositories and services
/// 5. Advances any overdue billing dates
/// 6. Re-schedules notifications for all active subscriptions
void main() async {
  // Required for async operations before runApp
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Hive local database (stores data in app documents directory)
  await Hive.initFlutter();

  // Register Hive type adapters for custom models
  // These are auto-generated by hive_generator via build_runner
  Hive.registerAdapter(SubscriptionAdapter());
  Hive.registerAdapter(SubscriptionCycleAdapter());
  Hive.registerAdapter(SubscriptionCategoryAdapter());
  Hive.registerAdapter(ReminderConfigAdapter());
  Hive.registerAdapter(MonthlySnapshotAdapter());

  // Initialize timezone database for accurate notification scheduling
  // This loads timezone data for all regions worldwide
  tz.initializeTimeZones();

  // Set local timezone to device's actual timezone
  // CRITICAL: Without this, all notifications schedule in UTC!
  try {
    // flutter_timezone 5.0.1+ returns TimezoneInfo instead of String
    final timezoneInfo = await FlutterTimezone.getLocalTimezone();
    // Extract the timezone name from TimezoneInfo object
    final String timeZoneName = timezoneInfo.identifier;
    tz.setLocalLocation(tz.getLocation(timeZoneName));
  } catch (e) {
    // Fallback to UTC if timezone detection fails
    debugPrint('⚠️ Failed to get local timezone: $e. Falling back to UTC.');
    tz.setLocalLocation(tz.getLocation('UTC'));
  }

  // Load bundled currency exchange rates from assets/data/exchange_rates.json
  // This enables multi-currency support without network calls
  await CurrencyUtils.loadExchangeRates();

  // Initialize RevenueCat for subscription management
  await EntitlementService.instance.initialize();

  // Create Riverpod container for dependency injection
  final container = ProviderContainer();

  // Initialize subscription repository (opens Hive box)
  // Using async provider pattern to handle initialization properly
  final repository = await container.read(subscriptionRepositoryProvider.future);

  // Open monthly snapshots box for analytics (stores historical spending data)
  // Used for month-over-month comparison in analytics screen
  await Hive.openBox<MonthlySnapshot>('monthly_snapshots');

  // Initialize notification service (sets up platform-specific handlers)
  // The provider now auto-initializes the service
  final notificationService = await container.read(notificationServiceProvider.future);

  // Advance billing dates that are in the past to prevent outdated reminders
  // This ensures the app catches up if it hasn't been opened in a while
  final updatedSubscriptions = await repository.advanceOverdueBillingDates();

  // Auto-resume subscriptions whose resumeDate has passed
  final resumedSubscriptions = await repository.autoResumeSubscriptions();

  // Re-schedule all notifications for active subscriptions + updated/resumed ones
  // This ensures notifications are up-to-date after app launch
  // (Needed because OS may clear scheduled notifications)
  final activeSubscriptions = repository.getAllActive();
  final affectedSubscriptions = {
    ...activeSubscriptions,
    ...updatedSubscriptions,
    ...resumedSubscriptions,
  }.toList();

  for (final subscription in affectedSubscriptions) {
    await notificationService.scheduleNotificationsForSubscription(subscription);
  }

  // Start the Flutter application
  runApp(
    UncontrolledProviderScope(
      container: container,
      child: const CustomSubsApp(),
    ),
  );
}
